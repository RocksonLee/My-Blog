<!DOCTYPE html><html lang="zh-CN"><head><title>USACO training 学习计划 - RocksonLee's Blog</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="dns-prefetch" href="https://blog.rockson.top/"><link rel="preload" href="https://cdn.jsdelivr.net/gh/RocksonLee/My-blog/assets/mdui/css/mdui.min.css" as="style"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/RocksonLee/My-blog/assets/mdui/css/mdui.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/gh/RocksonLee/My-blog/assets/theme/origin.css" as="style"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/RocksonLee/My-blog/assets/theme/origin.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/RocksonLee/My-blog/assets/icon/mqii/mqii.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/github.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/RocksonLee/My-blog/assets/markdown.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/custom.css"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/RocksonLee/My-blog/img/avatar_2.webp"><meta name="name" itemprop="name" content="RocksonLee's Blog"><meta name="description" itemprop="description" content="RocksonLee's Blog"><meta name="keywords" itemprop="keywords" content="RocksonLee's Blog"><meta name="image" itemprop="image" content="https://cdn.jsdelivr.net/gh/RocksonLee/My-blog/img/avatar_2.webp"><meta property="og:url" content="https://blog.rockson.top/"><meta property="og:type" content="blog"><meta property="og:title" content="RocksonLee's Blog"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/RocksonLee/My-blog/img/avatar_2.webp"><meta property="og:description" content="RocksonLee's Blog"><link rel="canonical" href="https://blog.rockson.top/"><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher":{
        "@type":"Organization",
        "name":"RocksonLee's Blog",
        "logo":"https://cdn.jsdelivr.net/gh/RocksonLee/My-blog/img/avatar_2.webp"
    },
    "url":"https://blog.rockson.top/",
    "image":{
        "@type":"ImageObject",
        "url":"https://cdn.jsdelivr.net/gh/RocksonLee/My-blog/img/avatar_2.webp"
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://blog.rockson.top/"
    },
    "description":""
}</script></head><body class="mdui-appbar-with-toolbar mdui-theme-accent-blue"><div class="mdui-progress" id='loading-progress' style="position: fixed;top:0;z-index: 999999;"><div class="mdui-progress-indeterminate"></div></div><div id="theme_css"></div><div class="mdui-appbar mdui-appbar-fixed mdui-appbar-scroll-hide"><div class="mdui-toolbar"><button class="mdui-btn mdui-btn-icon" mdui-drawer="{target:'#drawer'}" mdui-tooltip="{content: '菜单'}"><i class="mdui-icon material-icons">menu</i></button><a href="/" class="mdui-typo-title">RocksonLee's Blog</a><div class="mdui-toolbar-spacer"></div><div class="mdui-row mdui-hidden-sm-down"><a href="/tags/" target="_blank" rel="noopener" class="mdui-col text">标签云</a><a href="/categories/" target="_blank" rel="noopener" class="mdui-col text">分类</a><a href="/links/" target="_blank" rel="noopener" class="mdui-col text">友链</a><a href="/tools/" target="_blank" rel="noopener" class="mdui-col text">工具集</a><a href="/about/" target="_blank" rel="noopener" class="mdui-col text">关于</a></div><button class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: '切换主题'}" mdui-menu="{target: '#theme_menu',align: 'right',covered: false}"><i class="mdui-icon material-icons">view_quilt</i></button><ul class="mdui-menu" id="theme_menu" style="width: fit-content;"><li class="mdui-menu-item" mdui-tooltip="{content: '回归原本'}"><a onclick="theme('day')">日间模式</a></li><li class="mdui-menu-item" mdui-tooltip="{content: '晚上要保护眼睛哦'}"><a onclick="theme('night')">夜间模式</a></li><li class="mdui-menu-item" mdui-tooltip="{content: '满足你的少女心吧'}"><a onclick="theme('pink')">粉红</a></li><li class="mdui-menu-item" mdui-tooltip="{content: '没什么,就是淡蓝色'}"><a onclick="theme('blue')">粉蓝</a></li></ul><button mdui-dialog="{target:'#search_dialog'}" onclick="document.getElementById('search_input').focus();" class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: '搜索'}"><i class="mdui-icon material-icons">search</i></button><button id='toc_button' class="mdui-btn mdui-btn-icon" mdui-drawer="{target:'#toc_drawer'}" mdui-tooltip="{content: '目录'}" hidden><i class="mdui-icon material-icons">format_list_numbered</i></button></div></div><div class="mdui-container"><div id='page_typ' hidden>article</div><div class="mdui-card article"><a href="/posts/!USACO/"><div class="mdui-card-media"><img data-src="https://cdn.jsdelivr.net/gh/RocksonLee/My-blog/img/30.webp" height="300px" style="object-fit: cover;" src='https://cdn.jsdelivr.net/gh/RocksonLee/My-blog/assets/icon/loading.svg' alt></div></a><div class="mdui-card-primary"><a href="/posts/!USACO/" class="mdui-card-primary-title">USACO training 学习计划</a><div class="mdui-card-primary-subtitle"><a href="/tags/USACO/" class="mdui-chip"><span class="mdui-chip-title">USACO</span></a><a href="/tags/Training Records/" class="mdui-chip"><span class="mdui-chip-title">Training Records</span></a></div></div><div class="mdui-card-header"><img data-src="https://cdn.jsdelivr.net/gh/RocksonLee/My-Blog@master/img/avatar_2.webp" src='https://cdn.jsdelivr.net/gh/RocksonLee/My-blog/assets/icon/loading.svg' alt='avatar' class="mdui-card-header-avatar"><div class="mdui-card-header-title">RocksonLee</div><div class="mdui-card-header-subtitle">2022-03-15 13:33:25</div><div class="mdui-card-menu"><button class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: '文章分类'}" mdui-menu="{target:'#categories-list',align:'right',covered: false}"><i class="mdui-icon material-icons">bookmark</i></button><ul class="mdui-menu" id="categories-list"><li class="mdui-menu-item"><a href="/categories/Training Records/USACO/">Training Records/USACO</a></li></ul><button class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: '本文阅读量'}" mdui-menu="{target:'#visit_counter',align:'right',covered: false}"><i class="mdui-icon material-icons">remove_red_eye</i></button><ul class="mdui-menu" id="visit_counter"><li class="mdui-menu-item"><div id="busuanzi_container_page_pv"><center>本文总阅读量<span id="busuanzi_value_page_pv"></span>次</center></div></li></ul><button class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: '分享'}" mdui-menu="{target:'#share_menu',align:'right',covered: false}"><i class="mdui-icon material-icons">share</i></button><ul class="mdui-menu" id="share_menu" style="width: fit-content;"><li class="mdui-menu-item"><a id="share_weibo" href="https://service.weibo.com/share/share.php?appkey=&title=USACO training 学习计划 - RocksonLee's Blog&url=/posts/!USACO/&pic=https://cdn.jsdelivr.net/gh/RocksonLee/My-blog/img/avatar_2.webp&style=simple" target="_blank" rel="noopener"><i class="mdui-menu-item-icon mdui-icon mqii mqii-weibo"></i>分享到微博</a></li><li class="mdui-menu-item"><a id="share_qq" href="https://connect.qq.com/widget/shareqq/index.html?site=RocksonLee's Blog&title=USACO training 学习计划 - RocksonLee's Blog&summary=&pics=https://cdn.jsdelivr.net/gh/RocksonLee/My-blog/img/avatar_2.webp&url=/posts/!USACO/" target="_blank" rel="noopener"><i class="mdui-menu-item-icon mdui-icon mqii mqii-qq_filled"></i>分享到QQ</a></li><li class="mdui-menu-item"><a id="share_twitter" href="https://twitter.com/intent/tweet?text=USACO training 学习计划 - RocksonLee's Blog&url=/posts/!USACO/" target="_blank" rel="noopener"><i class="mdui-menu-item-icon mdui-icon mqii mqii-twitter"></i>分享到Twitter</a></li><li class="mdui-menu-item"><a id="share_copy" onclick="copylink()"><i class="mdui-menu-item-icon mdui-icon material-icons">link</i>复制链接</a></li></ul></div></div><div class="mdui-card-content"><div id="md-body" class="md-body text"><h1>前言</h1>
<p>USACO training 其实是很久之前就想彻底刷一遍的题单，但是因为其他的原因，一直没有完整的刷过一遍，这两个星期也有空，尝试刷刷吧！</p>
<h1>USACO Section 1</h1>
<h2>1.2.2</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P1200">Luogu</a></p>
<h3>Solution</h3>
<p>这一道题的思路就是把 A 类似这类的字母转化成 1 这类的数字。</p>
<p>然后暴力加减即可。</p>
<h3>Code</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: ride
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

void usaco(string problem)
{
    string in=problem+&quot;.in&quot;,out=problem+&quot;.out&quot;;
    freopen(in.c_str(),&quot;r&quot;,stdin);
    freopen(out.c_str(),&quot;w&quot;,stdout);
}

#define N 100
char a[N], b[N];
int ans1 = 1, ans2 = 1, len;

int main()
{
    usaco(&quot;ride&quot;);
    scanf(&quot;%s%s&quot;, a, b);
    len = strlen(a);
    for (int i = 0; i &lt; len; i++) ans1 *= a[i] - &#39;A&#39; + 1;
    len = strlen(b);
    for (int i = 0; i &lt; len; i++) ans2 *= b[i] - &#39;A&#39; + 1;
    if (ans1 % 47 == ans2 % 47)
        cout &lt;&lt; &quot;GO\n&quot;;
    else
        cout &lt;&lt; &quot;STAY\n&quot;;
    return 0;
}
</code></pre>
<h2>1.2.5</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P1201">Luogu</a></p>
<h3>Solution</h3>
<p>这道题我在做匹配的时候直接使用string，string的包装及使用都非常的重要，很有用啊。</p>
<p>匹配人，然后利用C++的整数运算会去掉小数部分的特性直接计算即可。</p>
<p>然后我们需要特判m=0的情况。</p>
<h3>Code</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: gift1
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

void usaco(string problem)
{
    string in = problem + &quot;.in&quot;, out = problem + &quot;.out&quot;;
    freopen(in.c_str(), &quot;r&quot;, stdin);
    freopen(out.c_str(), &quot;w&quot;, stdout);
}

map&lt;string, int&gt; mp;
int n, w, m;
string name[100], temp;
int main()
{
    usaco(&quot;gift1&quot;);
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++) cin &gt;&gt; name[i];
    for (int i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; temp &gt;&gt; w &gt;&gt; m; // w=money,m=people
        if (m) mp[temp] -= w / m * m;
        for (int j = 0; j &lt; m; j++)
        {
            cin &gt;&gt; temp;
            mp[temp] += w / m;
        }
    }
    for (int i = 0; i &lt; n; i++) printf(&quot;%s %d\n&quot;, name[i].c_str(), mp[name[i]]);
    return 0;
}
</code></pre>
<h2>1.2.6</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P1202">Luogu</a></p>
<h3>Solution</h3>
<p>这道题其实挺简单的，直接加上当前月份的天数就可以到第二月的13日。</p>
<p>1900.1.13是周六！</p>
<p>然后用一句很复杂（其实也不会）的三目运算符就可以解决当前月份的天数计算。</p>
<p><code>(m == 2 ? (((y % 4 == 0 &amp;&amp; y % 100 != 0) || y % 400 == 0) ? 29 : 28) : ((m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) ? 31 : 30))</code></p>
<p>先把最复杂的2月计算给分割开。</p>
<p>然后2月分闰不闰。</p>
<p>其他月份分大不大。</p>
<h3>Code</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: friday
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

void usaco(string problem)
{
    string in = problem + &quot;.in&quot;, out = problem + &quot;.out&quot;;
    freopen(in.c_str(), &quot;r&quot;, stdin);
    freopen(out.c_str(), &quot;w&quot;, stdout);
}

int x, w, ans[10];
int main()
{
    usaco(&quot;friday&quot;);
    scanf(&quot;%d&quot;, &amp;x);
    w = 5;
    for (int y = 1900; y &lt; 1900 + x; y++)
    {
        for (int m = 1; m &lt;= 12; m++)
        {
            ans[w]++;
            w += (m == 2 ? (((y % 4 == 0 &amp;&amp; y % 100 != 0) || y % 400 == 0) ? 29 : 28) : ((m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) ? 31 : 30));
            w %= 7;
        }
    }
    for (int i = 5; i &lt;= 10; i++) printf(&quot;%d &quot;, ans[i % 7]);
    printf(&quot;%d\n&quot;, ans[11 % 7]);
    return 0;
}
</code></pre>
<h2>1.2.7</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P1203">Luogu</a></p>
<h3>Solution</h3>
<p>对于这一道题，我们应该尝试破环成链。</p>
<p>然后对这个环跑一边，因为有白色是那种特殊的东西，所以我们特殊对待。</p>
<p>白色可接前可接后。</p>
<p><code><latex>a</latex></code> 记录最接近的白色左边位置。</p>
<p><code><latex>b</latex></code> 记录串右边位置。</p>
<p><code><latex>c</latex></code> 记录当前颜色。</p>
<p>最后记得 <code>min(ans,n)</code> 当你破环成链，然后整条链都是一种字符（不要抠字眼）时，那么会大于n，嗯。</p>
<h3>Code</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: beads
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

void usaco(string problem)
{
    string in=problem+&quot;.in&quot;,out=problem+&quot;.out&quot;;
    freopen(in.c_str(),&quot;r&quot;,stdin);
    freopen(out.c_str(),&quot;w&quot;,stdout);
}

#define N 1000
int n, a, b, ans, w;
char s[N], c;

int main()
{
    usaco(&quot;beads&quot;);
    scanf(&quot;%d %s&quot;, &amp;n, s);
    memcpy(s + n, s, n);
    for (int i = 0; i &lt; n&lt;&lt;1; i++)
    {
        if (s[i] == &#39;w&#39;)
            b++, w++;
        else if (s[i] == c)
            b++, w = 0;
        else
            ans = max(ans, a + b), a = b - w, b = w + 1, w = 0, c = s[i];
    }
    ans=max(ans,a+b);
    printf(&quot;%d\n&quot;, min(ans,n));
    return 0;
}
</code></pre>
<h2>1.3.2</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P1204">Luogu</a></p>
<h3>Solution</h3>
<p>记录连续区间最长的左值和右值，区间若断裂，则记录最长断裂区间。</p>
<h3>Code</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: milk2
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

struct qwq
{
    int l;
    int r;
} a[6000];
int n, ansl, ansr;
int maxn, minn;
int cmp(qwq a, qwq b)
{
    if (a.l == b.l)
        return a.r &lt; b.r;
    else
        return a.l &lt; b.l;
}

void usaco(string problem)
{
    string in = problem + &quot;.in&quot;, out = problem + &quot;.out&quot;;
    freopen(in.c_str(), &quot;r&quot;, stdin);
    freopen(out.c_str(), &quot;w&quot;, stdout);
}

int main()
{
    usaco(&quot;milk2&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 0; i &lt; n; i++) scanf(&quot;%d %d&quot;, &amp;a[i].l, &amp;a[i].r);
    sort(a, a + n, cmp);
    ansl = a[0].l, ansr = a[0].r;
    for (int i = 0; i &lt; n; i++)
    {
        if (ansr &lt; a[i].l) minn = max(minn, a[i].l - ansr), ansl = a[i].l, ansr = a[i].r;
        ansl = min(ansl, a[i].l), ansr = max(ansr, a[i].r);
        maxn = max(maxn, ansr - ansl);
    }
    printf(&quot;%d %d\n&quot;, maxn, minn);
    return 0;
}
</code></pre>
<h2>1.3.3</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P1205">Luogu</a></p>
<h3>solution</h3>
<p>纯暴力了，没啥好说，寄。</p>
<h3>Code</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: transform
LANG: C++
*/
#include&lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a,b) memset(a,b,sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

int n;
char a[15][15], b[15][15], c[15][15], d[15][15];
bool work1()
{
    for (int i = 1; i &lt;= n; i++)
    {
        for (int j = 1; j &lt;= n; j++)
            b[j][n - i + 1] = a[i][j];
    }
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= n; j++)
            if (b[i][j] != c[i][j])
                return 0;
    return 1;
}
bool work2()
{
    for (int i = 1; i &lt;= n; i++)
    {
        for (int j = 1; j &lt;= n; j++)
            b[n - i + 1][n - j + 1] = a[i][j];
    }
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= n; j++)
            if (b[i][j] != c[i][j])
                return 0;
    return 1;
}
bool work3()
{
    for (int i = 1; i &lt;= n; i++)
    {
        for (int j = 1; j &lt;= n; j++)
            b[n - j + 1][i] = a[i][j];
    }
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= n; j++)
            if (b[i][j] != c[i][j])
                return 0;
    return 1;
}
bool work4()
{
    for (int i = 1; i &lt;= n; i++)
    {
        for (int j = 1; j &lt;= n; j++)
            b[i][n - j + 1] = a[i][j];
    }
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= n; j++)
            if (b[i][j] != c[i][j])
                return 0;
    return 1;
}
bool work5()
{
    work4();
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= n; j++)
            a[i][j] = b[i][j];
    if (work1())
        return 1;
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= n; j++)
            a[i][j] = b[i][j];
    if (work2())
        return 1;
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= n; j++)
            a[i][j] = b[i][j];
    if (work3())
        return 1;
    return 0;
}
bool work6()
{
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= n; j++)
            if (b[i][j] != c[i][j])
                return 0;
    return 1;
}
void work()
{
    if (work1())
    {
        cout &lt;&lt; &quot;1\n&quot;;
        return;
    }
    if (work2())
    {
        cout &lt;&lt; &quot;2\n&quot;;
        return;
    }
    if (work3())
    {
        cout &lt;&lt; &quot;3\n&quot;;
        return;
    }
    if (work4())
    {
        cout &lt;&lt; &quot;4\n&quot;;
        return;
    }
    if (work5())
    {
        cout &lt;&lt; &quot;5\n&quot;;
        return;
    }
    if (work6())
    {
        cout &lt;&lt; &quot;6\n&quot;;
        return;
    }
    cout &lt;&lt; &quot;7\n&quot;;
}

void usaco(string problem)
{
    string in=problem+&quot;.in&quot;,out=problem+&quot;.out&quot;;
    freopen(in.c_str(),&quot;r&quot;,stdin);
    freopen(out.c_str(),&quot;w&quot;,stdout);
}

int main()
{
    usaco(&quot;transform&quot;);
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= n; j++)
        {
            cin &gt;&gt; a[i][j];
            d[i][j] = a[i][j];
        }
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= n; j++)
            cin &gt;&gt; c[i][j];
    work();
    return 0;
}
</code></pre>
<h2>1.3.4</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P3864">Luogu</a></p>
<h3>solution</h3>
<p>这道题就是简单的搜索，或者说是循环也可。</p>
<p>输入一次字典和编号。</p>
<p>然后说出可能的名字，循环为 <code><latex>3^n</latex></code> 次。</p>
<h3>Code</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: namenum
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

string dict[5000];
int cnt = 0;
bool ans = false;
string kb[10] = {&quot;&quot;, &quot;&quot;, &quot;ABC&quot;, &quot;DEF&quot;, &quot;GHI&quot;, &quot;JKL&quot;, &quot;MNO&quot;, &quot;PRS&quot;, &quot;TUV&quot;, &quot;WXY&quot;};

inline void dfs(string namenum, string result)
{
    if (namenum.empty())
    {
        if (*lower_bound(dict, dict + 4617, result) == result)
        {
            cout &lt;&lt; result &lt;&lt; endl;
            if (!ans) ans = true;
        }
    }
    else
        for (int i = 0; i &lt; 3; i++) dfs(namenum.substr(1), result + kb[namenum[0] - &#39;0&#39;][i]);
    return;
}

void usaco(string problem)
{
    string in = problem + &quot;.in&quot;, out = problem + &quot;.out&quot;;
    freopen(in.c_str(), &quot;r&quot;, stdin);
    freopen(out.c_str(), &quot;w&quot;, stdout);
}

int main()
{
    usaco(&quot;namenum&quot;);
    string namenum;
    cin &gt;&gt; namenum;
    freopen(&quot;dict.txt&quot;, &quot;r&quot;, stdin);
    for (int i = 0; i &lt; 4617; i++) cin &gt;&gt; dict[i];
    dfs(namenum, &quot;&quot;);
    if (!ans) cout &lt;&lt; &quot;NONE&quot; &lt;&lt; endl;
    return 0;
}
</code></pre>
<h2>1.3.5</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P1207">Luogu</a></p>
<h3>solution</h3>
<p>对于这道题，我们直接在结构体编写函数，以及编写一个初始化函数。</p>
<p>那么针对每一数，我们都可以搞一个答案出来。</p>
<h3>Code</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: palsquare
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

void usaco(string problem)
{
    string in = problem + &quot;.in&quot;, out = problem + &quot;.out&quot;;
    freopen(in.c_str(), &quot;r&quot;, stdin);
    freopen(out.c_str(), &quot;w&quot;, stdout);
}

int b;
inline char c(int x)
{
    if (x &gt;= 0 &amp;&amp; x &lt;= 9) return x + &#39;0&#39;;
    return x - 10 + &#39;A&#39;;
}
struct node
{
    int l, a[20];
    node(int x)
    {
        for (l = 0; x; l++) a[l] = x % b, x /= b;
    }
    void out()
    {
        for (int i = l - 1; i &gt;= 0; i--) printf(&quot;%c&quot;, c(a[i]));
    }
    bool tf()
    {
        for (int i = 0; i &lt; l; i++)
            if (a[i] != a[l - i - 1]) return false;
        return true;
    }
};
int main()
{
    usaco(&quot;palsquare&quot;);
    scanf(&quot;%d&quot;, &amp;b);
    for (int i = 1; i &lt;= 300; i++)
    {
        node n(i * i);
        if (n.tf())
        {
            node m(i);
            m.out();
            putchar(&#39; &#39;);
            n.out();
            putchar(&#39;\n&#39;);
        }
    }
    return 0;
}
</code></pre>
<h2>1.3.6</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P1207">Luogu</a></p>
<h3>Solution</h3>
<p>与上一题的解决方法不尽相同。</p>
<h3>Code</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: dualpal
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

struct Num
{
    int val[100], pp, n;
    Num(int x, int p)
    {
        for (n = 0; x; n++) val[n] = x % p, x /= p;
    }
    bool check()
    {
        for (int i = 0; i &lt; n; i++)
            if (val[i] != val[n - i - 1]) return false;
        return true;
    }
};

void usaco(string problem)
{
    string in=problem+&quot;.in&quot;,out=problem+&quot;.out&quot;;
    freopen(in.c_str(),&quot;r&quot;,stdin);
    freopen(out.c_str(),&quot;w&quot;,stdout);
}

int main()
{
    usaco(&quot;dualpal&quot;);
    int ans = 0;
    int n, s;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;s);
    for (int i = s + 1; ans &lt; n; i++)
    {
        int ok = 0;
        for (int j = 2; j &lt; 11; j++)
        {
            Num temp(i, j);
            if (temp.check()) ok++;
        }
        if (ok&gt;=2) printf(&quot;%d\n&quot;, i), ans++;
    }
    return 0;
}
</code></pre>
<h2>1.4.2</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P1208">Luogu</a></p>
<h3>Solution</h3>
<p>我们思考一下，贪心，就是需要把最便宜的先买了再说。</p>
<p>再买贵点的。</p>
<p>所以排序一下，再去买。</p>
<h3>Code</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: milk
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

#define N 200200
pair&lt;int, int&gt; q[N];
int x, n, ans;

void usaco(string problem)
{
    string in = problem + &quot;.in&quot;, out = problem + &quot;.out&quot;;
    freopen(in.c_str(), &quot;r&quot;, stdin);
    freopen(out.c_str(), &quot;w&quot;, stdout);
}

int main()
{
    usaco(&quot;milk&quot;);
    scanf(&quot;%d%d&quot;, &amp;x, &amp;n);
    for (int i = 0; i &lt; n; i++) scanf(&quot;%d%d&quot;, &amp;q[i].first, &amp;q[i].second);
    sort(q, q + n);
    for (int i = 0; i &lt; n &amp;&amp; x &gt; 0; i++)
    {
        ans += (x &lt; q[i].second ? x : q[i].second) * q[i].first;
        x -= q[i].second;
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>
<h2>1.4.3</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P1209">Luogu</a></p>
<h3>Solution</h3>
<p>对于这道题，我们还是尝试贪心做法，先有一块木板从头铺到尾，然后再断开 <strong>最长</strong> 的地方，重复断开 <code><latex>m-1</latex></code> 处，就可以只使用 <code><latex>m</latex></code> 块木板了。</p>
<p>特判你的牛的数量如果比木板多，那就是不是直接放就好呢。</p>
<h3>Code</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: barn1
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

#define N 500
int m, s, c, a[N], w[N];
int cmp(int a, int b)
{
    return a &gt; b;
}

void usaco(string problem)
{
    string in=problem+&quot;.in&quot;,out=problem+&quot;.out&quot;;
    freopen(in.c_str(),&quot;r&quot;,stdin);
    freopen(out.c_str(),&quot;w&quot;,stdout);
}

int main()
{
    usaco(&quot;barn1&quot;);
    scanf(&quot;%d%d%d&quot;,&amp;m,&amp;s,&amp;c);
    if (m &gt; c) { printf(&quot;%d\n&quot;, c); return 0; }
    for (int i = 0; i &lt; c; i++) scanf(&quot;%d&quot;, &amp;a[i]);
    sort(a, a + c);
    int ans = a[c - 1] - a[0] + 1;
    for (int i = 1; i &lt; c; i++) w[i] = a[i] - a[i - 1];
    sort(w + 1, w + c, cmp);
    for (int i = 1; i &lt;= m - 1; i++) ans -= w[i] - 1;
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>
<h2>1.4.5</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P1211">Luogu</a></p>
<h3>Solution</h3>
<p>暴力拆解每一位，我们从100-999直接循环就好了，用一个函数解决重复问题（值得学习）。</p>
<h3>Code</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: crypt1
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

int a[20], n, ans;
il int check(int x)
{
    for (int i = 0; i &lt; n; i++)
    {
        if (a[i] == x) return true;
    }
    return false;
}

il bool find(int xx, int p)
{
    for (int k = 0, x = xx; x; k++, x /= 10)
        if (k == p || !check(x % 10)) return false;
    return true;
}

void usaco(string problem)
{
    string in=problem+&quot;.in&quot;,out=problem+&quot;.out&quot;;
    freopen(in.c_str(),&quot;r&quot;,stdin);
    freopen(out.c_str(),&quot;w&quot;,stdout);
}

int main()
{
    usaco(&quot;crypt1&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
    for (int i = 100; i &lt;= 999; i++)
    {
        for (int j = 10; j &lt;= 99; j++)
        {
            int now1 = i * (j % 10), now2 = i * (j / 10), now3 = i * j;
            if (find(i, 3) &amp;&amp; find(j, 2) &amp;&amp; find(now1, 3) &amp;&amp; find(now2, 3) &amp;&amp; find(now3, 4)) ans++;
        }
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>
<h2>1.4.6</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P2693">Luogu</a></p>
<h3>Solution</h3>
<p>枚举锁头的每一位即可。</p>
<h3>Code</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: combo
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

int n, a[10], b[10];
bool flag[120][120][120];
ll ans;

void usaco(string problem)
{
    string in = problem + &quot;.in&quot;, out = problem + &quot;.out&quot;;
    freopen(in.c_str(), &quot;r&quot;, stdin);
    freopen(out.c_str(), &quot;w&quot;, stdout);
}

int main()
{
    usaco(&quot;combo&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    scanf(&quot;%d%d%d&quot;, &amp;a[1], &amp;a[2], &amp;a[3]);
    scanf(&quot;%d%d%d&quot;, &amp;b[1], &amp;b[2], &amp;b[3]);
    for (int i = -2; i &lt;= 2; i++)
        for (int j = -2; j &lt;= 2; j++)
            for (int k = -2; k &lt;= 2; k++)
            {
                if (!flag[(a[1] + i + n) % n][(a[2] + j + n) % n][(a[3] + k + n) % n]) ans++;
                flag[(a[1] + i + n) % n][(a[2] + j + n) % n][(a[3] + k + n) % n] = true;
            }
    for (int i = -2; i &lt;= 2; i++)
        for (int j = -2; j &lt;= 2; j++)
            for (int k = -2; k &lt;= 2; k++)
            {
                if (!flag[(b[1] + i + n) % n][(b[2] + j + n) % n][(b[3] + k + n) % n]) ans++;
                flag[(b[1] + i + n) % n][(b[2] + j + n) % n][(b[3] + k + n) % n] = true;
            }
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}
</code></pre>
<h2>1.4.7</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P1212">Luogu</a></p>
<h3>Solution</h3>
<p>这道题的解法也是相当简单，比前面的题要求码力高一点。</p>
<p>首先你从一个传送门出来，进入第二个传送门，你是直接进入第一个传送门出来的右边第一个。</p>
<p>其次你走遍所有传送门最多就是所有传送门的个数。</p>
<p>然后你预处理一个门右面的那个门的位置。</p>
<p>暴力 DFS！</p>
<h3>Code</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: wormhole
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

#define N 20
int n;
struct qwq
{
    int x;
    int y;
} mp[N];
bool cmp(qwq a, qwq b)
{
    if (a.y == b.y)
        return a.x &lt; b.x;
    else
        return a.y &lt; b.y;
}
int r[N], to[N];
int ans;

bool is_cycle()
{
    for (int i = 1; i &lt;= n; i++)
    {
        int pos = i;
        for (int cnt = 1; cnt &lt;= n &amp;&amp; pos; cnt++)
            pos = r[to[pos]];
        if (pos) return true;
    }
    return false;
}

void dfs(int step, int pre)
{
    if (step &gt;= n)
    {
        if (is_cycle()) ans++;
    }
    else
        for (int i = pre + 1; i &lt;= n; i++)
            if (!to[i])
                for (int j = i + 1; j &lt;= n; j++)
                    if (!to[j])
                    {
                        to[i] = j, to[j] = i;
                        dfs(step + 2, i);
                        to[i] = to[j] = 0;
                    }
}

void usaco(string problem)
{
    string in = problem + &quot;.in&quot;, out = problem + &quot;.out&quot;;
    freopen(in.c_str(), &quot;r&quot;, stdin);
    freopen(out.c_str(), &quot;w&quot;, stdout);
}

int main()
{
    usaco(&quot;wormhole&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;mp[i].x, &amp;mp[i].y);
    sort(mp + 1, mp + n + 1, cmp);
    for (int i = 1; i &lt;= n; i++)
        if (mp[i].y == mp[i + 1].y) r[i] = i + 1;
    dfs(0, 0);
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>
<h2>1.4.8</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P3650">Luogu</a></p>
<h3>Solution</h3>
<p>尝试枚举最小到最大这个区间，这个区间的数来当这个所被允许的区间的左端点。</p>
<p>那么你在每一次枚举中计算每个山峰给你带来的贡献。</p>
<p>统计最小贡献就可以了。</p>
<h3>Code</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: skidesign
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

int n, now, ans = INF;

#define N 1000

int a[N];

void usaco(string problem)
{
    string in=problem+&quot;.in&quot;,out=problem+&quot;.out&quot;;
    freopen(in.c_str(),&quot;r&quot;,stdin);
    freopen(out.c_str(),&quot;w&quot;,stdout);
}

int main()
{
    usaco(&quot;skidesign&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
    sort(a + 1, a + n + 1);
    for (int i = a[i]; i &lt;= a[n]; i++)
    {
        for (int j = 1; j &lt;= n; j++)
        {
            if (a[j] + 17 &lt; i) now += (i-a[j] - 17) * (i-a[j] - 17);
            if (a[j] &gt; i) now += (a[j]-i) * (a[j]-i);
        }
        ans = min(ans, now);
        now = 0;
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>
<h2>1.5.2</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P1214">Luogu</a></p>
<h3>Solution</h3>
<p>对于这道题，我们应该想清楚他要让我们干什么。</p>
<p>找到一个长度为n的等差数列，这个等差数列的数满足 <code><latex>{ x | p^2 + q^2\ \ \ p,q \in N \cap [0,m] }</latex></code>。</p>
<p>而且输出需要按照 <code><latex>b</latex></code> 为第一关键字，<code><latex>a</latex></code> 为第二关键字进行排序。</p>
<p>所以我们再找这个的时候要记得按照 <code><latex>b</latex></code> 在外循环，<code><latex>a</latex></code> 在内循环。</p>
<p>然后暴力检查合不合法，那恭喜你，<strong>超时</strong> 啦！</p>
<p>因为 USACO 的内存限制为 16MB，但不要被这么小的内存限制住手脚，因为这个内存还可以开大约 4000000 的int数组，我们将 <code><latex>p^2 + q^2</latex></code> 预处理，用空间换时间，是不是很爽。</p>
<p><code><latex>m \leq 250</latex></code> 所以只需要开 250000 左右的数组即可。</p>
<p>ok想好就开始搞！</p>
<h3>Code</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: ariprog
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

int n, top, flag, s[100000], check[250 * 250 * 2 + 100], tot;

void usaco(string problem)
{
    string in=problem+&quot;.in&quot;,out=problem+&quot;.out&quot;;
    freopen(in.c_str(),&quot;r&quot;,stdin);
    freopen(out.c_str(),&quot;w&quot;,stdout);
}

int main()
{
    usaco(&quot;ariprog&quot;);
    scanf(&quot;%d %d&quot;, &amp;n, &amp;top);
    for (int i = 0; i &lt;= top; i++)
        for (int j = 0; j &lt;= top; j++)
            s[++tot] = i * i + j * j;
    for (int i = 0; i &lt;= top; i++)
        for (int j = 0; j &lt;= top; j++)
            check[i * i + j * j] = true;
    sort(s + 1, s + tot + 1);
    int m = unique(s + 1, s + tot + 1) - s;

    for (int i = 1; i * (n - 1) &lt;= top * top + top * top; i++)
    {
        for (int j = 1; j &lt;= m &amp;&amp; s[j] + i * (n - 1) &lt;= top * top + top * top; j++)
        {
            int now = i + s[j], ans = 1;
            while (check[now] &amp;&amp; ans &lt; n) now += i, ans++;
            if (ans == n) printf(&quot;%d %d\n&quot;, s[j], i), flag = true;
        }
    }
    if (flag == false) printf(&quot;NONE\n&quot;);
    return 0;
}
</code></pre>
<h2>1.5.3</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P1215">Luogu</a></p>
<h3>Solution</h3>
<p>对于这道题，我使用宽度（广度）优先搜索 BFS 进行解答。</p>
<p>对于每一个桶的的状态，使用 <strong>空间换时间</strong> 的方式进行判重。</p>
<p>装满溢出，还是完全倒干净，这样解决。</p>
<p><code><latex> change = min ( limit - now , another_bottle_now) </latex></code></p>
<p>然后最后储存答案。</p>
<blockquote><p>当 <code><latex>a</latex></code> 桶是空的时候，<code><latex>c</latex></code> 桶中牛奶所剩量的所有可能性。</p>
</blockquote>
<h3>Code</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: milk3
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

struct qwq
{
    int a, b, c;
    int step;
};

queue&lt;qwq&gt; q;

int n, checkx[30 * 30 * 30 + 100], limita, limitb, limitc, ans[30];

int check(qwq x)
{
    if (checkx[x.a * n * n + x.b * n + x.c]) return true;
    if (x.a == 0) ans[x.c] = true;
    checkx[x.a * n * n + x.b * n + x.c] = true;
    return false;
}

void bfs()
{
    while (!q.empty())
    {
        qwq temp, now = q.front();
        int change;
        if (now.a)
        {
            temp = now;
            change = min(limitb - temp.b, temp.a);
            temp.b += change, temp.a -= change;
            if (!check(temp)) q.push(temp);
            temp = now;
            change = min(limitc - temp.c, temp.a);
            temp.c += change, temp.a -= change;
            if (!check(temp)) q.push(temp);
        }
        if (now.c)
        {
            temp = now;
            change = min(limita - temp.a, temp.c);
            temp.a += change, temp.c -= change;
            if (!check(temp)) q.push(temp);
            temp = now;
            change = min(limitb - temp.b, temp.c);
            temp.b += change, temp.c -= change;
            if (!check(temp)) q.push(temp);
        }
        if (now.b)
        {
            temp = now;
            change = min(limita - temp.a, temp.b);
            temp.a += change, temp.b -= change;
            if (!check(temp)) q.push(temp);
            temp = now;
            change = min(limitc - temp.c, temp.b);
            temp.c += change, temp.b -= change;
            if (!check(temp)) q.push(temp);
        }
        q.pop();
    }
}

void usaco(string problem)
{
    string in = problem + &quot;.in&quot;, out = problem + &quot;.out&quot;;
    freopen(in.c_str(), &quot;r&quot;, stdin);
    freopen(out.c_str(), &quot;w&quot;, stdout);
}

int main()
{
    usaco(&quot;milk3&quot;);
    scanf(&quot;%d%d%d&quot;, &amp;limita, &amp;limitb, &amp;limitc);
    n = max(limita, max(limitb, limitc)) + 1;
    q.push((qwq){0, 0, limitc, 0});
    bfs();
    bool flag = false;
    for (int i = 0; i &lt; 30; i++)
    {
        if (ans[i])
        {
            if (flag) printf(&quot; &quot;);
            printf(&quot;%d&quot;, i);
            flag = true;
        }
    }
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
<h2>1.6.2</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P1216">Luogu</a></p>
<h3>Solution</h3>
<p>对于这道题，我们的递推方程是这样的。</p>
<p><code><latex>f[i][j]=max{f[i-1][j],f[i-1][j-1]}+a[i][j]</latex></code></p>
<p>于是就写完了。</p>
<h3>Code</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: numtri
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

#define N 1010

int a[N][N], temp, maxn = -INF, n;

void usaco(string problem)
{
    string in = problem + &quot;.in&quot;, out = problem + &quot;.out&quot;;
    freopen(in.c_str(), &quot;r&quot;, stdin);
    freopen(out.c_str(), &quot;w&quot;, stdout);
}

int main()
{
    usaco(&quot;numtri&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i++)
    {
        for (int j = 1; j &lt;= i; j++)
        {
            scanf(&quot;%d&quot;, &amp;temp);
            a[i][j] = temp + max(a[i - 1][j], a[i - 1][j - 1]);
            if (i == n)
                maxn = max(maxn, a[i][j]);
        }
    }
    printf(&quot;%d\n&quot;, maxn);
    return 0;
}
</code></pre>
<h2>1.6.3</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P1217">Luogu</a></p>
<h3>Solution</h3>
<p>这道题有两种方法</p>
<p>第一个枚举各位上的数，然后判断是否为素数。</p>
<p>第二种则是素数筛，判断素数。</p>
<p>我采用第二种。</p>
<p>但是 USACO 他卡我！！空间！！！</p>
<p>那么没办法了，打表吧。</p>
<h3>Code</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: pprime
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

int a[1000]={5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899};

void usaco(string problem)
{
    string in = problem + &quot;.in&quot;, out = problem + &quot;.out&quot;;
    freopen(in.c_str(), &quot;r&quot;, stdin);
    freopen(out.c_str(), &quot;w&quot;, stdout);
}

int main()
{
    usaco(&quot;pprime&quot;);
    int s, e;
    cin &gt;&gt; s &gt;&gt; e;
    for (int j = 0;; j++)
    {
        if (j &gt;= 1000) break;
        if (a[j] &gt;= s &amp;&amp; a[j] &lt;= e) cout &lt;&lt; a[j] &lt;&lt; endl;
        if (a[j] &gt; e) break;
        if (a[j] &lt; s) continue;
    }
    return 0;
}
</code></pre>
<h3>Code2</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: pprime
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

#define N 10000000

int prime[N/10], ptot = 0;
bool vis[N];

void get_prime(int n)
{
    vis[0] = vis[1] = true;
    for (int i = 2; i &lt;= n; i++)
    {
        if (!vis[i]) prime[++ptot] = i;
        for (int j = 1; j &lt;= ptot &amp;&amp; i * prime[j] &lt;= n; j++)
        {
            vis[i * prime[j]] = true;
            if (i % prime[j] == 0) break;
        }
    }
}

bool check(int x)
{
    int temp[10], tot = 0;
    while (x)
    {
        temp[++tot] = x % 10;
        x /= 10;
    }
    for (int i = 1; i &lt;= tot; i++)
        if (temp[i] != temp[tot - i + 1]) return false;
    return true;
}

void usaco(string problem)
{
    string in = problem + &quot;.in&quot;, out = problem + &quot;.out&quot;;
    freopen(in.c_str(), &quot;r&quot;, stdin);
    freopen(out.c_str(), &quot;w&quot;, stdout);
}

int main()
{
    usaco(&quot;pprime&quot;);
    int l, r;
    scanf(&quot;%d %d&quot;, &amp;l, &amp;r);
    if (r &gt; 10000000) r = 9999999;
    get_prime(r);
    for (int i = 1; i &lt;= ptot; i++)
    {
        if (prime[i] &lt; l) continue;
        if (check(prime[i])) printf(&quot;%d\n&quot;, prime[i]);
    }
    return 0;
}
</code></pre>
<h2>1.6.4</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P1218">Luogu</a></p>
<h3>Solution</h3>
<p>我们只需要用欧拉筛筛出质数，然后对质数进行一个拆分，再检查是否合法即可。</p>
<p>但是，USACO 我爱你，又爆内存了，那么看到这个输入这么简单。</p>
<p><code><latex>n \leq 8</latex></code></p>
<p>我直接就打表吧!</p>
<h3>Code1</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: sprime
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

void usaco(string problem)
{
    string in = problem + &quot;.in&quot;, out = problem + &quot;.out&quot;;
    freopen(in.c_str(), &quot;r&quot;, stdin);
    freopen(out.c_str(), &quot;w&quot;, stdout);
}

int main()
{
    usaco(&quot;sprime&quot;);
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    if (n == 8) printf(&quot;23399339\n29399999\n37337999\n59393339\n73939133\n&quot;);
    if (n == 7) printf(&quot;2339933\n2399333\n2939999\n3733799\n5939333\n7393913\n7393931\n7393933\n&quot;);
    if (n == 6) printf(&quot;233993\n239933\n293999\n373379\n373393\n593933\n593993\n719333\n739391\n739393\n739397\n739399\n&quot;);
    if (n == 5) printf(&quot;23333\n23339\n23399\n23993\n29399\n31193\n31379\n37337\n37339\n37397\n59393\n59399\n71933\n73331\n73939\n&quot;);
    if (n == 4) printf(&quot;2333\n2339\n2393\n2399\n2939\n3119\n3137\n3733\n3739\n3793\n3797\n5939\n7193\n7331\n7333\n7393\n&quot;);
    if (n == 3) printf(&quot;233\n239\n293\n311\n313\n317\n373\n379\n593\n599\n719\n733\n739\n797\n&quot;);
    if (n == 2) printf(&quot;23\n29\n31\n37\n53\n59\n71\n73\n79\n&quot;);
    if (n == 1) printf(&quot;2\n3\n5\n7\n&quot;);
    return 0;
}
</code></pre>
<h3>Code2</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: sprime
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

#define N 100000000

int prime[N / 10], ptot = 0;
bool vis[N];

void get_prime(int n)
{
    vis[0] = vis[1] = true;
    for (int i = 2; i &lt;= n; i++)
    {
        if (!vis[i]) prime[++ptot] = i;
        for (int j = 1; j &lt;= ptot &amp;&amp; i * prime[j] &lt;= n; j++)
        {
            vis[i * prime[j]] = true;
            if (i % prime[j] == 0) break;
        }
    }
}

void usaco(string problem)
{
    string in = problem + &quot;.in&quot;, out = problem + &quot;.out&quot;;
    freopen(in.c_str(), &quot;r&quot;, stdin);
    freopen(out.c_str(), &quot;w&quot;, stdout);
}

int main()
{
    usaco(&quot;sprime&quot;);
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    n = (int)pow(10, n);
    get_prime(n);
    for (int i = 1; i &lt;= ptot; i++)
    {
        if (prime[i] &lt; n / 10) continue;
        if (prime[i] &gt; n) break;
        int x = prime[i];
        while (x)
        {
            if (vis[x]) break;
            x /= 10;
        }
        if (!x) printf(&quot;%d\n&quot;, prime[i]);
    }
    return 0;
}
</code></pre>
<h1>USACO Section 2</h1>
<h2>2.1.3</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P1457">Luogu</a></p>
<h3>Solution</h3>
<p>首先进行墙的二进制拆分</p>
<p>然后对图进行一个染色，输出颜色数量</p>
<p>接着检查每个颜色记录大小并输出</p>
<blockquote><p>选择最佳的墙来推倒。有多解时选最靠西的，仍然有多解时选最靠南的。同一格子北边的墙比东边的墙更优先。
用该墙的南邻单位的北墙或西邻单位的东墙来表示这面墙，方法是输出邻近单位的行数、列数和墙的方位（ N（北）或者 E（东））。</p>
</blockquote>
<p>因此，我们从左下向右上搜索，然后记录最大值</p>
<p>最后输出一下</p>
<h3>Code</h3>
<pre><code class="lang-cpp">/*
ID: RocksonLee
TASK: castle
LANG: C++
*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define il inline
#define INF 0x3f3f3f3f
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

#define N 60

int n, m, ansx, ansy, ansn, answay, temp;

bool wall[N][N][5];

int color[N][N], ctot, size[N * N];

queue&lt;pair&lt;int, int&gt;&gt; q;

void bfs(int x, int y)
{
    if (color[x][y]) return;
    ctot++;
    q.push(make_pair(x, y));
    while (!q.empty())
    {
        int i = q.front().first, j = q.front().second;
        q.pop();
        if (color[i][j]) continue;
        color[i][j] = ctot;
        if (!color[i + 1][j] &amp;&amp; !wall[i][j][3]) q.push(make_pair(i + 1, j));
        if (!color[i][j + 1] &amp;&amp; !wall[i][j][2]) q.push(make_pair(i, j + 1));
        if (!color[i - 1][j] &amp;&amp; !wall[i][j][1]) q.push(make_pair(i - 1, j));
        if (!color[i][j - 1] &amp;&amp; !wall[i][j][0]) q.push(make_pair(i, j - 1));
    }
}

void usaco(string problem)
{
    string in=problem+&quot;.in&quot;,out=problem+&quot;.out&quot;;
    freopen(in.c_str(),&quot;r&quot;,stdin);
    freopen(out.c_str(),&quot;w&quot;,stdout);
}

int main()
{
    usaco(&quot;castle&quot;);
    scanf(&quot;%d%d&quot;, &amp;m, &amp;n);
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= m; j++)
        {
            scanf(&quot;%d&quot;, &amp;temp);
            for (int k = 0; k &lt; 4; k++) wall[i][j][k] = temp &amp; (1 &lt;&lt; k);
        }
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= m; j++)
            bfs(i, j);
    printf(&quot;%d\n&quot;, ctot);
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= m; j++)
            size[color[i][j]]++;
    for (int i = 1; i &lt;= ctot; i++)
        ansn = max(ansn, size[i]);
    printf(&quot;%d\n&quot;, ansn);
    ansn = 0;
    for (int j = 1; j &lt;= m; j++)
        for (int i = n; i &gt;= 1; i--)
        {
            if (color[i][j] != color[i - 1][j] &amp;&amp; ansn &lt; size[color[i][j]] + size[color[i - 1][j]])
            {
                ansn = size[color[i][j]] + size[color[i - 1][j]];
                answay = 1;
                ansx = i;
                ansy = j;
            }
            if (color[i][j] != color[i][j + 1] &amp;&amp; ansn &lt; size[color[i][j]] + size[color[i][j + 1]])
            {
                ansn = size[color[i][j]] + size[color[i][j + 1]];
                answay = 2;
                ansx = i;
                ansy = j;
            }
        }
    printf(&quot;%d\n&quot;, ansn);
    printf(&quot;%d %d %c\n&quot;, ansx, ansy, (answay == 1 ? &#39;N&#39; : &#39;E&#39;));
    return 0;
}
</code></pre>
<h2>2.1.4</h2>
<h3>Problem</h3>
<p><a href="https://www.luogu.com.cn/problem/P1458">Luogu</a></p>
</div></div></div><div class="mdui-row-xs-3 article"><div class="mdui-col"><a href="/posts/!USACO-training/" class="text" id='pre_button'><i class="mdui-icon material-icons">arrow_back</i>USACO training 学习计划</a></div><div class="mdui-col mdui-text-center">USACO training 学习计划</div><div class="mdui-col"><a href="/posts/!Study-Note/" class="text mdui-float-right" id='nxt_button'>学习笔记<i class="mdui-icon material-icons">arrow_forward</i></a></div></div><div class="mdui-card" style="margin-top: 50px;"><div class="mdui-card-primary"><div class="mdui-card-primary-title"><i class="mdui-icon material-icons">comment</i>评论</div></div><div class="mdui-card-content" id='comments'><center><div class="mdui-spinner"></div></center></div></div><script>
function SetComment(){
    window.comment=new Valine({
        el: '#comments',
        placeholder: "说几句嘛qwq",
        appId: "M4mC8E08McE8QJWN35fbUT9X-MdYXbMMI",
        appKey: "PVAi8n10SbrDMHVbNwrW2gRr",
        path: window.location.pathname,
    });
}
function GenComment(){
    document.getElementById('comments').innerHTML=`<center><div class="mdui-spinner mdui-spinner-colorful"></div></center>`;
    mdui.mutation(document.getElementById('comments'));

    if(document.getElementById("comment_js"))SetComment();
    else{
        var valinejs=document.createElement('script');
        valinejs.id="comment_js";
        valinejs.src="https://cdn.jsdelivr.net/gh/xCss/Valine/dist/Valine.min.js";
        valinejs.async=true;
        valinejs.onload=SetComment;
    }
    document.getElementsByTagName("head")[0].appendChild(valinejs);
}
</script></div><div class="mdui-drawer mdui-drawer-close" id="drawer"><ul class="mdui-list"><li class='mdui-subheader'>Pages</li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"style='color:black'">bookmark_border</i><a href="/tags/" target="_blank" rel="noopener" class="mdui-list-item-content">标签云</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"style='color:black'">book</i><a href="/categories/" target="_blank" rel="noopener" class="mdui-list-item-content">分类</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"style='color:black'">link</i><a href="/links/" target="_blank" rel="noopener" class="mdui-list-item-content">友链</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"style='color:black'">build</i><a href="/tools/" target="_blank" rel="noopener" class="mdui-list-item-content">工具集</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"style='color:black'">person</i><a href="/about/" target="_blank" rel="noopener" class="mdui-list-item-content">关于</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"style='color:black'">rss_feed</i><a href="/atom.xml" target="_blank" rel="noopener" class="mdui-list-item-content">订阅</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"style='color:black'">list</i><a href="/sitemap.xml" target="_blank" rel="noopener" class="mdui-list-item-content">站点地图</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"style='color:black'">comment</i><a href="https://rocksonlee.avosapps.us" target="_blank" rel="noopener" class="mdui-list-item-content">评论管理</a></li><li class='mdui-subheader'>Catch me</li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon material-icons"style='color:dodgerblue'">email</i><a href="mailto:lixuanzhang0629@163.com" target="_blank" rel="noopener" class="mdui-list-item-content">给我写信</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon mqii mqii-telegram"style='color:#66ccff'"></i><a href="https://t.me/RocksonLee" target="_blank" rel="noopener" class="mdui-list-item-content">电报</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon mqii mqii-twitter"style='color:rgba(29,161,242,1.00)'"></i><a href="https://twitter.com/RocksonLee_" target="_blank" rel="noopener" class="mdui-list-item-content">推特</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon mqii mqii-bilibili"style='color:#F06292'"></i><a href="https://space.bilibili.com/456088161" target="_blank" rel="noopener" class="mdui-list-item-content">哔哩哔哩</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon mqii mqii-netease-cloud-music"style='color:red'"></i><a href="https://music.163.com/#/user/home?id=3718936185" target="_blank" rel="noopener" class="mdui-list-item-content">网易云音乐</a></li><li class="mdui-list-item"><img class="mdui-list-item-icon" src="/img/links/luogu.webp" alt><a href="https://www.luogu.com.cn/user/146852" target="_blank" rel="noopener" class="mdui-list-item-content">洛谷</a></li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon mqii mqii-github"style='color:black'"></i><a href="https://github.com/RocksonLee" target="_blank" rel="noopener" class="mdui-list-item-content">Github</a></li><li class='mdui-subheader'>Links</li><li class="mdui-list-item"><i class="mdui-list-item-icon mdui-icon mqii mqii-telegram"style='color:#bbb'"></i><a href="https://travellings.link/" target="_blank" rel="noopener" class="mdui-list-item-content">Traveling</a></li></ul></div><div class="mdui-drawer mdui-drawer-close mdui-drawer-right" id="toc_drawer" hidden><ul class="mdui-list" id="toc"></ul></div></body><button class="mdui-fab mdui-fab-mini mdui-fab-fixed mdui-fab-hide" id="totop" onclick="totop()" style="z-index: 99999;"><i class="mdui-icon material-icons">keyboard_arrow_up</i></button><footer class="mdui-m-t-5"><div class="mdui-card"><div class="mdui-card-content mdui-p-a-5"><div class="mdui-container"><div class="mdui-row-sm-3"><div class="mdui-col"><div class="mdui-row"><div class="mdui-col-xs-2 mdui-col-sm-1 mdui-col-md-1" style="margin: 10px;"><a href="https://github.com/RocksonLee" target="_blank" rel="noopener"><i class="mdui-icon mqii mqii-github"></i></a></div><div class="mdui-col-xs-2 mdui-col-sm-1 mdui-col-md-1" style="margin: 10px;"><a href="https://space.bilibili.com/456088161" target="_blank" rel="noopener"><i class="mdui-icon mqii mqii-bilibili"></i></a></div><div class="mdui-col-xs-2 mdui-col-sm-1 mdui-col-md-1" style="margin: 10px;"><a href="https://www.zhihu.com/people/rocksonlee-6" target="_blank" rel="noopener"><i class="mdui-icon mqii mqii-zhihu"></i></a></div><div class="mdui-col-xs-2 mdui-col-sm-1 mdui-col-md-1" style="margin: 10px;"><a href="https://twitter.com/RocksonLee_" target="_blank" rel="noopener"><i class="mdui-icon mqii mqii-twitter"></i></a></div></div></div><div class="mdui-col mdui-text-center"><span>Copyright ©&nbsp;2020-2021&nbsp;RocksonLee's Blog</span><div><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div><script async src="https://cdn.jsdelivr.net/gh/RocksonLee/My-blog/assets/busuanzi.js" onload="window.addEventListener('load',busuanzi);document.addEventListener('pjax:complete',busuanzi);"></script><div>last build:2022-04-02 09:30:13</div></div><div class="mdui-col mdui-text-center mdui-typo"><div>Powered by<a href="https://github.com/zcmimi/py-blog" target="_blank" rel="noopener">py-blog</a></div><div>Theme<a href="https://github.com/zcmimi/py-blog-theme-material" target="_blank" rel="noopener">material</a></div></div></div></div></div></div></footer><div class="mdui-dialog" id="search_dialog" style="min-height: 50%;"><div class="mdui-dialog-title">Search</div><div class="mdui-dialog-content"><div class="mdui-textfield"><i class="mdui-icon material-icons">search</i><input id="search_input" class="mdui-textfield-input" placeholder="搜索"></div><div id="search_result" class="mdui-list"></div></div></div><script async src='https://cdn.jsdelivr.net/gh/RocksonLee/My-blog/assets/local_search.js'></script><script>document.getElementById('search_input').onchange=function(){search("/pure_data.json");}</script><script async defer src="https://cdn.jsdelivr.net/gh/RocksonLee/My-blog/assets/mdui/js/mdui.min.js"></script><script async defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js"></script><script async defer src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script><script defer src='https://cdn.jsdelivr.net/gh/RocksonLee/My-blog/assets/bundle.min.js'></script><script defer src='/custom.js'></script><script defer>
window.addEventListener('load',()=>{try{GenComment();}catch{}});
document.addEventListener('pjax:complete',()=>{try{GenComment();}catch{}});
</script></html>